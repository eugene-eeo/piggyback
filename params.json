{"name":"Piggyback","tagline":"recursive module importer","body":"```\r\nPython  _                     _             _\r\n   _ __(_)__ _ __ _ _  _ _  _| |__  __ _ __| |__\r\n  | '_ \\ / _` / _` | || | || | '_ \\/ _` / _| / /\r\n  | .__/_\\__, \\__, |\\_, |\\_, |_.__/\\__,_\\__|_\\_\\\r\n  |_|    |___/|___/ |__/ |__/\r\n```\r\n\r\nPython package for finding modules recursively and then\r\nimporting them. Useful for scripts/libraries which expose\r\nDSL-like stuff, like test suites and configuration.\r\n\r\nDevelopment goals include extensibility and stability. We\r\naim for a robust API that although doesn't do much does what\r\nit does well. Currently we think that we've reached those\r\ngoals.\r\n\r\n```python\r\nfrom piggyback.finder import Finder\r\nfrom piggyback.lookup import Loader\r\n\r\nimporter = Loader(Finder('path'))\r\nfor module in importer.search():\r\n    print(module)\r\n\r\ncache = importer.import_all()\r\nmodule = cache['path.module']\r\n```\r\n\r\nLet Piggyback manage all the hackery required for you and\r\ngo write some code. No more manual `execfiles` and namespace\r\nmanagement madness. Piggyback does importing and namespaces\r\nright, namely:\r\n\r\n- We isolate every `__import__`ed module, and their namespaces\r\n  are separate of one another, as well as the current module.\r\n  No namespace clashes.\r\n\r\n- The `sys.path` variable remains unchanged at the end of the\r\n  importing- Piggyback will ensure that the `sys.path` is\r\n  cleansed of all appended paths once we are finished with\r\n  the importing.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}